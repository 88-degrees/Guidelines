# C++ 编码规范

## 背景

C++ 是各种操作系统、应用软件的主要编程语言之一。
C++ 语言有许多强大的的功能，同时也包含了复杂的特性；这使得它容易导致BUG，变得难以阅读和维护。

编写这个规范的目的是管理 C++ 语言的复杂度，阐述编写代码过程中哪些该做哪些不该做。
程序员遵循这些规则与规范，更好地运用 C++ 语言的优点，代码则更好管理与维护。

规范，有时我们也称之为可读性，是管控 C++ 代码的各种约定。
规范的条款，不应该被误解，因为这些约定远大于源代码的格式。
开源的项目更应该参考这个规范。

这篇规范不是一个 C++ 的教程，我们假定你已经熟悉了这门语言。

## 目标

- 让规范发挥更大的作用

- 为读者而优化，不是程序员

- 保持代码的一致性

- 保证更多 C++ 代码社区的一致

- 避免以外的危险的构造

- 避免让水平一般的 C++ 程序员难以维护代码

- 基于代码规模而考虑

- 允许适当的优化

## C++ 版本

这篇规范主要着眼于 C++ 11 这个版本，不用 C++ 14 或者 C++ 17 的特性。
随着时间的推移，我们也将积极的推进版本的更新。

应该避免代码中出现那些从最新版本中（C++ 17）删除的特性，以及有不同含义的个例。
有些 C++ 特性是禁止的不允许的。不要采用非标准的扩展。

## 头文件

通常，一个 `.h` 文件对应于一个 `.cc` 文件。
也有例外，比如，一些单元测试的文件包含的  `.cc` 文件只有一个 `main()` 函数。

正确使用头文件可以带来代码可读性的提升，同时也有助于代码的性能和维护代码量。

下面的规则帮助你规避使用头文件的错误。

### 独立的头文件

头文件应该是独立存在的（自编译的），头文件以 `.h` 结尾。
被包含的非头文件应该以 `.inc` 结尾，并且要有节制的使用。

所有头文件都应该独立存在。用户和重构工具不应该赋予包含头文件特殊的条件。
特别地，一个头文件应该防止包含它所需要的所有头文件。

最好将模板的定义、内联函数和它们的声明都放在同一个文件中。
每个 `.cc` 文件用到的结构体定义都应该被包含进来，否则容易导致某些编译配置下的链接失败。
如果声明和定义放在不同的文件中，前面的包含应该关联后面的包含。
不要把定义分开的放在被包含的不同的头文件中（ `-inl.h` ）；以前有人认为是对的，以后不被允许。

例外的情况：
模板通常被所有相关的模板参数显示地实例化。
一个类的私有实现，可以定义在有且仅有一个 `.cc` 源文件中来实例化这个模板。

很少有被包含的非独立的头文件，在一个文件的不同位置引用这个头文件（比如文件中部）。
有些程序员要么不使用头文件保护符，要么不包含先决条件，将一些文件用 `.inc` 扩展名命名。
我们要尽可能使用独立的头文件。

### `#define` 保护符

`#define` 保护符可以防止头文件被多重引用。
通常我们采用这样的格式：`<PROJECT>_<PATH>_<FILE>_H_`

在整个项目的源代码树的路径中应该保持唯一性。
例如，项目 `foo` 有一个文件 `foo/src/bar/baz.h` ，我们做下面的定义：

```C++
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

...

#endif  // FOO_BAR_BAZ_H_
```
### 前置声明

尽可能避免前置声明。你需要的时候才 `#include` 头文件。

**定义：**

“前置声明”指的是声明一个类、函数或者模板却没有相应的定义。

**优点：**

- 前置声明可以节省编译时间，因为 `#include` 迫使编译器打开更多的文件处理更多的输入。
- 前置声明可以省掉不必要的重复编译，由于头文件不相关的改变，`#include` 迫使代码经常被重复编译。

**缺点：**

- 前置声明将独立性给隐藏起来，当头文件改变时，用户可以跳过必须的重复编译。
- 库函数的改变会被前置声明打断，函数和模板前置声明可以防止一个头文件的拥有者对他的API做一些不兼容的修改。
例如扩大一个参数类型，用缺省值增加一个模板参数，迁移到新的命名空间。
- 前置声明 `std::` 命名空间中的符号经常会导致未定义的行为。
- 很难断定一个前置声明或者一个完整的 `#include` 是必须的。用前置声明取代 #include通常会悄悄地改变代码的含义：

```C++
// b.h:
struct B {};
struct D : B {};

// good_user.cc:
#include "b.h"
void f(B*);
void f(void*);
void test(D* x) { f(x); }  // 调用 f(B*)
```
> 如果 `B` 和 `D` 的前置声明取代了 `#include` ，`test()` 将会调用 `f(void*)` 。

- 在一个头文件里面做多个符号的前置声明要比简单的 `#include` 这个头文件更繁复。
- 为了允许前置声明而构建的代码（例如用指针来取代对象成员）会导致代码更复杂更慢。

**结论：**

- 尽可能避免在其他项目的实体中定义前置声明。
- 当使用一个头文件中的函数声明时，总是 `#include` 这个头文件。
- 使用类模板时，总是 `#include` 这个头文件。

> 参考  [命名和包含的顺序](#命名和包含的顺序) ，了解什么时候  `#include` 头文件。

### 内联函数

仅仅当一个函数只有10行或者更少时使用内联函数。

**定义：**

内联函数和普通函数的不同是编译器在编译的时候可以展开这些代码行，而不是通过通常的机制来调用它。

**优点：**

由于内联函数更小巧，可以生成更有效率的目标代码。鼓励将取值函数，设值函数，以及其它短的或对性能要求较高的函数进行内联。

**缺点：**

过度使用内联实际上会拖慢程序。内联一个函数会导致代码大小增加或减少（取决于函数大小）。
将一个非常小的取值函数内联化通常可以减少代码的大小，
而将一个非常大的函数内联化则会戏剧性地增加代码大小。
现代处理器由于更好的利用了指令缓存, 小巧的代码往往执行更快。

**结论：**

一个较为合理的经验法则是：不要内联超过**10**行的函数。
谨慎对待析构函数，它们通常会比看起来要更长，因为有隐式的成员函数和基类的析构函数的调用。

另一个实用的经验法则是：
内联带有循环或 `switch` 语句的函数常常得不偿失（除非大多数情况下不会执行循环或 `switch` ）。

一个被声明为内联的函数不是总会被内联展开，这点很重要。
例如，虚函数和递归函数一般不会被内联。通常递归函数也不应该被内联。
将一个虚函数声明为内联的主要原因是为方便起见而将它的定义放进类中，
或是当作一种文档，比如取值和设值函数。

### 命名和包含的顺序

采用标准的包含次序可以增加代码可读性，避免隐藏的依赖关系，
例如：头文件、C 库、C++ 库、其它库的 `.h` 文件，和本项目的 `.h` 文件。

项目内头文件应按照项目源代码目录树的结构来排列，避免使用 UNIX 特殊的快捷目录 `.` 和 `..`。
例如，`awesome-project/src/base/logging.h` 应该这样被包含：

```C++
#include "base/logging.h"
```

 在源文件 `dir/foo.cc` 或者  `dir/foo_test.cc` 中，
 主要目的是为了实现或者测试 `dir2/foo2.h`，下面应该是你应该遵循的顺序：
 
 1. `dir2/foo2.h`
 2. 一个空行
 3. C 系统文件
 4. C++ 系统文件
 5. 一个空行
 6. 其他库的 `.h` 文件
 7. 本项目的 `.h` 文件
 
 > 注意：任何临近的空行应该被折叠。
 
 按这种顺序，如果 `dir2/foo2.h ` 省略了任何必要的头文件，`dir/foo.cc` 的构建就会中止。
 这个法则确保构建的中止首先会被这些文件的使用者发现，而不用等到其它封装的无知的人来发现。

`dir/foo.cc` 和 `dir2/foo2.h` 一般在相同的目录下（例如 `base/basictypes_test.cc` 和 `base/basictypes.h` ），但也可以在不同的目录下。

>  类似于 `stddef.h` 这样的 C 兼容头文件通常和它们的 C++ 副本（cstddef） 可以互换。
虽然两者的形式都可以接受，但是要保持代码的一致性。

各部分的引入文件应该按字母顺序排列。请注意，旧的代码可能不符合这个规则，应该在方便的时候修复这个问题。

你应该使用前面提到的符号定义去包含这些头文件，除去前置声明的异常情况。
如果你使用了 `bar.h` 中的符号，不要不顾及这一点：`foo.h` （当前又）包含了 `bar.h` 。
你应该包含  `bar.h` ，除非 `foo.h` 已经表明它声明了 `bar.h` 中的符号。
但是，当前引用相关的头文件不需要把 cc 文件（例如，`foo.cc` 可以依赖于 `foo.h` 文件的引用）中包含的头文件再引用一遍。

举个例子，`awesome-project/src/foo/internal/fooserver.cc` 可能是像下面这样引用文件的：

```C++
#include "foo/server/fooserver.h"

#include <sys/types.h>
#include <unistd.h>
#include <vector>

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/server/bar.h"
```

**例外：**

有时候特定系统的源代码需要有条件的引用。条件引用可以放到其他引用的后面。
当然，我们要保证特定系统的代码小巧而集中，例如：

```C++
#include "foo/public/fooserver.h"

#include "base/port.h"  // C++ 11 这样用

#ifdef LANG_CXX11
#include <initializer_list>
#endif  // LANG_CXX11
```

## 作用域

### 命名空间

除了少数的例外，应该把代码防止命名空间里面。
对于命名空间，要基于项目来选择它的名字，也可以基于路径。不用加上 `using` 指示符（例如：`using namespace foo` ）。
不要使用内联命名空间。如果使用不具名的命名空间，请参考 [不具名的命名空间和静态变量](#不具名的命名空间和静态变量)。

**定义：**

命名空间将全局作用域细分成不同的、有名字的作用域，可以有效避免全局作用域下的命名冲突。

**优点：**

在大量的程序中，命名空间提供了一种防止名字冲突的方法，这样在代码中我们可以合理地使用短名字。

例如，如果两个不同的项目的全局作用域下都有一个名字为 `Foo` 的类，运行或者编译时这两个名字就可能会出现冲突。
如果每个项目都把代码放入它们自己的命名空间中，新的名字  `project1::Foo` 和 `project2::Foo` 现在就不会冲突了，
从而每个项目都可以继续引用 `Foo` 这个类而不需要加前缀。

内联命名空间把名字放在一个封闭作用域内。例如，下面的代码片段：

```C++
namespace outer {
inline namespace inner {
  void foo();
}  // namespace inner
}  // namespace outer
```

表达式 `outer::inner::foo()` 和 `outer::foo()` 是可以互换的。
内联命名空间主要是为了保证跨版本的ABI兼容性。

**缺点：**

命名空间也可能令人迷惑，因为它让我们理解一个名字指向的定义的机制复杂化了。

当名字被声明的时候，由于没有实际地被限制到命名空间，内联命名空间容易带来混乱。

在一些代码的上下文中，有必要将符号重复的指向完全形式的名字。如果是深层嵌套的命名空间，这会造成一些杂乱。

**结论：**

命名空间应该这样用：

- 遵循 [命名空间名字] 里的规则。
- 结束命名空间需要有代码注释。（见下面的例子）
- 用命名空间把引入语句、全局符号 [gflags](https://gflags.github.io/gflags/) 的定义 / 声明、以及其它命名空间类的前置声明之外的源代码包裹起来：

```C++
// 在 .h 头文件里
namespace mynamespace {

// 所有生命都必须放到名字空间内部
// 注意名字空间不用缩进
class MyClass {
 public:
  ...
  void Foo();
};

}  // namespace mynamespace
```

```C++
// 在 .cc 源文件里
namespace mynamespace {

// 函数的定义都要写在名字空间内部
void MyClass::Foo() {
  ...
}

}  // namespace mynamespace
```

更复杂的 `.cc` 文件会有补充信息，例如 `flags` 和 `using` 声明：

```C++
#include "a.h"

DEFINE_FLAG(bool, someflag, false, "dummy flag");

namespace mynamespace {

using ::foo::bar;

...code for mynamespace...    // 代码不要超出左边界

}  // namespace mynamespace
```

- 在 `.proto` 文件中使用 `package` 定义器，可以将协议消息代码放到一个命名空间中。
参考 [协议缓存包](https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#package)。
- 不要在 `namespace std` 中做任何声明，包括 C++ 标准库里面的类的前置声明。
在 `namespace std` 中声明实体是未定义的行为，代码是不可移植的。
要声明标准库中的东西就直接引入相应的头文件。
- 不推荐用 `using` 指示符来引入一个命名空间中所有可用的名字。

```C++
// 禁用：这样做会污染这个命名空间
using namespace foo;
```
- 在头文件的命名空间的范围内不要使用命名空间的别名，除非你要明确地标记内联命名空间。
因为一个头文件里面对任何命名空间的引用都会变成这个文件输出 API 的一部分。

```C++
// 简短的访问 .cc 文件里面用到的名字
namespace baz = ::foo::bar::baz;
```

```C++
// 简短的访问 .h 文件里面用到的名字
namespace librarian {
namespace impl {  // 内置的，不是 API 的一部分
namespace sidetable = ::pipeline_diagnostics::sidetable;
}  // namespace impl

inline void my_inline_function() {
// 一个函数（或者方法）在名字空间里的别名
namespace baz = ::foo::bar::baz;
...
}
}  // namespace librarian
```

- 不要使用内联命名空间。

### 不具名的命名空间和静态变量

如果一个 `.cc` 文件里面的定义不需要被外部文件引用，要么把它们放到不具名的命名空间里，要么声明为静态的 `static` 。不要在 `.h` 文件中使用这些结构。

**定义：**

把声明放到不具名的命名空间里，所有声明都可以被内部链接。
将函数和变量声明为静态的 `static` ，它们也会被内部链接。这么做意味着其它文件不能访问这些声明。如果一个不同的文件用同样的名字做了某些声明，那么两个实体将完全独立存在。

**结论：**

如果代码不需要在别的地方被引用，鼓励在 `.cc` 文件中使用内部链接。但是不要在 `.h` 文件中使用内部链接。

像具名的命名空间一样的格式去书写不具名的命名空间。在后面断行的注释里，将命名空间的名字置空：

```C++
namespace {
...
}  // namespace
```

### 非成员函数、静态成员函数和全局函数

推荐使用在命名空间内的非成员函数或是静态成员函数来取代全局函数；尽可能全面地少用全局函数。不要简单地用一个类去组合静态函数。一个类的静态方法通常应该和这个类的实现以及静态数据相关联。

**优点：**

非成员函数和静态成员函数在一些场合很有用。将非成员函数放入一个命名空间内可以避免污染全局空间。

**缺点：**

将非成员函数和静态成员函数作为一个新的类的成员时可能更有意义，尤其是当它们访问外部资源或是有着显著的依赖关系时。

**结论：**

定义一个不属于类的实例的函数有时是有用的。这样的一个函数可以是静态成员函数或是非成员函数。
非成员函数应该不依赖于外部变量，且应该在命名空间内。
仅仅为了将静态成员函数组合起来而创建一个类是没有任何必要的。这和将这些函数加上统一的前缀没什么区别。

如果仅仅是因为 `.cc` 文件的需要而定义一个非成员函数，采用内部链接限制它的范围。

### 局部变量

将一个函数的变量放置在可能的最小范围，并在声明中初始化变量。

C++ 允许在函数内部的任何地方声明变量。你应该尽可能局部地声明变量，并且尽可能靠近首先使用它的地方。
这样更容易找到变量的声明，读懂变量的类型，从而知道它被初始化成什么样子。特别地，初始化应该和声明以及赋值用在一起，而不是单独用。例如：

```C++
int i;
i = f();      // 不好 -- 初始化和声明分开了
```
```C++
int j = g();  // 很好 -- 声明并且同时初始化
```
```C++
std::vector<int> v;
v.push_back(1);  // 最好用花括号初始化
v.push_back(2);
```
```C++
std::vector<int> v = {1, 2};  // 很好 -- v 向量被初始化了
```

使用 `if` 、 `while` 和 `for` 这些语句的时候，变量先要被声明，这样变量就被限定到这些作用域里面了，例如：

```C++
while (const char* p = strchr(str, '/')) str = p + 1;
```

这里有一个警告：如果变量是一个对象，每次进入作用域里面它的构造函数都将被调用，每次离开作用域析构函数又将被调用：

```C++
// 效率低下的实现代码：
for (int i = 0; i < 1000000; ++i) {
  Foo f;  // 这里析构函数和构造函数要调用1000000次
  f.DoSomething(i);
}
```

在一个循环的作用域外面声明一个变量，代码更有效率：

```C++
Foo f;  // 构造函数和析构函数应该只被调用一次
for (int i = 0; i < 1000000; ++i) {
  f.DoSomething(i);
}
```

### 静态和全局变量

采用 [静态存储期限](http://en.cppreference.com/w/cpp/language/storage_duration#Storage_duration) 的对象是禁用的，
除非对象是 [全面可析构的](http://en.cppreference.com/w/cpp/types/is_destructible)。
非正式地讲，即使把成员函数和基类的析构函数考虑在内，这也意味着析构函数什么都没有做。
更正式地讲，这意味着类型没有用户定义的或者虚拟的析构函数，所有基类和非静态成员函数都是全面的可析构的。
静态函数的局部变量可能使用动态的初始化。对于静态类成员变量和命名空间范围内的变量使用动态初始化是不被鼓励的，不过可以有节制的使用，请参考下面的细节。

一般而言：如果一个全局变量的声明满足下面的条件，可以用 `constexpr` 修饰：

**定义：**

每个对象都有一个存储期限，与它的生存周期相关。静态存储期限的对象的生命从初始化开始直到程序结束。
这样的对象在命名空间的范围内表现为变量的形式，就像类的静态数据成员一样，
或者像一个由 `static` 标识符声明的本地函数级别的变量。
本地函数级别的变量可以通过它们的声明传参来初始化。
所有静态存储期限的对象作为程序开始的一部分被初始化。
当程序退出时，所有静态存储期限的对象都被销毁（在被脱离的线程终止之前）。

初始化可以是动态的，这意味着在初始化过程中并非全面地完成了。
（例如，一个构造函数申请了内存，一个变量随着当前的进程ID被初始化。）
而其他类型的初始化是静态初始化。然而，这两者并不完全对立：
静态初始化总是出现在对象和它的静态存储期限（用一个常量初始化这个对象或者表现为将所有字节都置成零），
如果需要的话，动态初始化出现在这个过程后面。

**优点：**

在大量的应用中，全局变量和静态变量都用途广泛：命名的常量、某些翻译器的辅助数据结构、命令行标志、日志、注册过程、后台架构等等。

**结论：**

#### 析构

当析构函数微不足道的情况下，它们的执行通常根本不以它们的顺序为准（它们实际上没有“运行”）。
否则，我们会有在对象的生命周期结束时访问对象的风险。因此，我们仅仅允许静态存储期限的对象是全面可析构的。
基础类型是全面可析构的（比如 `pointers` 和 `int` ），因为它是全面可析构的类型的数组。
注意，用 `constexpr` 修饰的变量是全面可析构的。

```C++
const int kNum = 10;  // 被允许

struct X { int n; };
const X kX[] = {{1}, {2}, {3}};  // 被允许

void foo() {
static const char* const kMessages[] = {"hello", "world"};  // 被允许
}

// 被允许: constexpr 保证了全面可析构
constexpr std::array<int, 3> kArray = {{1, 2, 3}};
```

```C++
// 不好：非全面的析构函数
const string kFoo = "foo";

// 不好：同样的原因，即使 kBar 是一个引用
// 这个规则同样适用于生命周期延长的临时对象
const string& kBar = StrCat("a", "b", "c");

void bar() {
// 不好：非全面的析构函数
static std::map<int, int> kData = {{1, 0}, {2, 0}, {3, 0}};
}
```

> 引用不是对象，不会导致可析构性的约束。动态初始化的约束依然适用。
特别地，允许本地函数级别的静态引用，例如： `T& t = *new T;`

#### 初始化

初始化是一个更复杂的命题。我们不仅仅应该考虑到类构造函数的执行，也应该考虑到初始化器：

```C++
int n = 5;    // 很好
int m = f();  // ? (依赖于 f)
Foo x;        // ? (依赖于 Foo::Foo)
Bar y = g();  // ? (依赖于 g 和 Bar::Bar)
```

首要注意的是我们不明确初始化的顺序。

C++ 标准中的形式语言提到了常量初始化。
一个初始化表达式如果是常量表达式，如果对象呗构造函数调用而初始化，
那么构造函数必须也被定义成 `constexpr` ：

```C++
struct Foo { constexpr Foo(int) {} };

int n = 5;  // 很好，5是一个常量表达式
Foo x(2);   // 很好，2是一个常量表达式，选定的构造函数是 constexpr
Foo a[] = { Foo(1), Foo(2), Foo(3) };  // 很好
```

常量初始化是被允许的。静态存储期限的常量初始化要用  `constexpr` 标记。否则，可能就有 [ABSL_CONST_INIT](https://github.com/abseil/abseil-cpp/blob/03c1513538584f4a04d666be5eb469e3979febba/absl/base/attributes.h#L540)这个属性。任何非本地的静态存储期限不用这样标记，应该被认为是动态初始化，并且做仔细地检查。

相反地，下面的初始化可能会有问题：

```C++
// 下面使用了某些声明：
time_t time(time_t*);      // 没有用 constexpr
int f();                   // 没有用 constexpr
struct Bar { Bar() {} };

// 可能有问题的初始化：
time_t m = time(nullptr);  // 初始化的表达式不是常量表达式
Foo y(f());                // 同上
Bar b;                     // 构造函数 Bar::Bar() 没有用 constexpr
```

不鼓励对非本地变量使用动态初始化，通常也禁止这么做。
但是，如果程序中没有对所有其他初始化做出这类初始化的序列，那就是可以的。
在这些限制之下，初始化的排序没有明显的区别。例如：

```C++
int p = getpid();  // 被允许，既然没有其它静态变量引用p
                   // 那么 p 自己可以初始化
```

允许动态的初始化静态本地变量。

#### 常用句式

- 全局字符串：如果需要一个全局或者静态的字符串常量，可以用简单的字符数组，或者将字符指针指向字串常值得第一个元素。字串常值通常有静态存储期限就够了。
- `Maps` ，集合（ `Sets` ）和其他动态容器：假如你需要一个静态的、固定的集合容器，比如搜索或查找表。你不能像从标准库中引用静态变量那样使用动态容器，因为它们没有全面的析构函数。相反，可以使用一种简单的全面类型，比如 `ints` 数组的数组（ `map<int,int>` ），或者一对值的数组（ `int` 和 `const char *` ）。对于小型集合，线性搜索就完全足够了（由于内存的局部性）。用二进制搜索算法也可以保持集合必要的排序。如果你喜欢标准库的动态容器，考虑采用本地方法静态指针，参考下面。
- 智能指针（ `unique_ptr` 、 `shared_ptr ` ）：析构过程中会完成智能指针的清理，因此禁止这么用。考虑到你的用例是否符合本章节中描述的其他模式之一。一个简单的解决方法是，将一个普通指针指向一个动态分配的对象而不要销毁它（参见最后的章节）。
- 自定义类型的静态变量：如果你需要一个静态的、常量的类型数据定义自身，给这个类型以全面的析构函数和 `constexpr` 构造函数。
- 你可以将指针绑定到本地函数静态指针变量上，动态地创造一个对象而不销毁它： `static const auto* const impl = new T(args...);` （如果这个初始化更复杂，它可以被放到一个函数中或者一个 `lambda` 表达式里面。）

### 线程本地变量

一个函数内部没有声明的线程本地变量必须随着一个运行时变量被初始化。同时要强制使用 [ABSL_CONST_INIT](https://github.com/abseil/abseil-cpp/blob/03c1513538584f4a04d666be5eb469e3979febba/absl/base/attributes.h#L540)这个属性。
采用 `thread_local` 而不是其他方法来定义线程本地数据。

**定义：**

从 C++ 11 版本开始，线程本地变量是用 `thread_local` 被声明的：

```C++
thread_local Foo foo = ...;
```

线程本地变量通常是一个对象的集合，所以不同的线程访问它的时候，访问的是不同的对象。在许多方面看来，线程本地变量更像是 [静态和全局变量](#静态和全局变量)。例如，命名空间范围内、函数里面或者作为静态类成员都可以声明线程本地变量，但是不能被任务是普通的类成员。

线程本地变量更像是静态变量一样被初始化。除非必须在每个线程里面被独立的初始化，而不是程序开始时初始化一次。
线程本地变量在函数内部声明是安全的，像静态变量一样，线程本地变量也同样有着初始化顺序的问题。

当线程终止的时候线程本地变量实例就被销毁，所以它不像静态变量那样有销毁的顺序问题。

**优点：**

- 线程本地数据从根本上说是竞争安全的（因为通常只有一个线程可以访问它）。并发程序中常常这样使用。
- `thread_local` 是创建线程本地数据唯一的标准支持方法。

**缺点：**

- 访问一个线程本地变量可能触发一定量的不可预测和不可控的其它代码。
- 线程本地变量实际上是全局变量，除了线程安全之外，它有所有全局变量的缺点。
- 通常来讲，类成员不能是 `thread_local` 。
-  `thread_local` 不可能像某些编译器内部函数那样高效。

**结论：**

函数内部的线程本地变量无需安全性的考虑，因而可以不加限制的使用。
注意：可以通过定义一个函数或者静态方法来暴露线程本地变量，函数内部的 `thread_local` 可以模拟一个类或者命名空间内部的 `thread_local` ：

```C++
Foo& MyThreadLocalFoo() {
  thread_local Foo result = ComplicatedInitialization();
  return result;
}
```

类或者命名空间内部的线程本地变量可以用一个真正的编译时常量来初始化（它们必须没有动态初始化）。
为了让这种情况强制执行，类或者命名空间内部的线程本地变量必须用[ABSL_CONST_INIT](https://github.com/abseil/abseil-cpp/blob/03c1513538584f4a04d666be5eb469e3979febba/absl/base/attributes.h#L540)这个属性（或者 `constexpr` ，不过这个比较少见）来修饰：

```C++
ABSL_CONST_INIT thread_local Foo foo = ...;
```

`thread_local` 应该作为定义线程本地数据优先于其它机制的首选。

## 类

类是 C++ 代码的基础单元。自然而然地，我们会大量的采用它。
这个章节列举了我们在编写一个类时主要能做和不能做的事情。

### 构造函数的工作

避免在构造函数中的虚方法调用，如果你不能发出错误信号，应该避免可能失败的初始化操作。

**定义：**

在构造函数的主体中有可能执行任意的初始化操作。

**优点：**

- 没有必要担心类是否被初始化。
- 构造函数调用完整地初始化了对象，可能是常数；也可能被更简单地用于标准容器或者算法。

**缺点：**

- 如果任务调用了虚函数，这些调用将不被派发到子类的实现中。
对类的未来的修改可能会把这种问题悄悄地，即使你的类当前没有被子类化，这样导致很多混淆。
- 并没有简单的方法可以让构造函数发送错误信号，除非程序崩溃（不总是恰当的）或者使用了异常（[禁止](#异常)这样做）。
- 如果任务执行失败了，我们现在得到了一个代码初始化失败的对象。
因此，请求一个 `bool IsValid()` 的状态检查机制（或类似的）会变成不正常的状态，很容易遗忘调用的过程。
- 你不能得到一个构造函数的地址，所以不论构造函数里的任务如何完成你都无法把它交给其它的线程。

**结论：**

构造函数不应该调用虚函数。对应于代码，终止程序意味着一个相应的错误处理响应。
否则，我们应该考虑使用 [TotW #42](https://abseil.io/tips/42) 中描述的工厂函数或者 `Init()` 方法。
如果一个类的公共的方法被调用（以这种形式半构造化的对象特别难以正确地工作），应该避免在一个没有其它状态的对象上调用 `Init()` 方法。

### 隐式转换

不要定义隐式转换。使用 `explicit` 关键字来修饰转换操作和单参数构造函数。

**定义：**

对象的一个类型（称之为 源类型）被用在一个被期望的不同类型时（称之为 目标类型），这种操作是隐式转换。
比如，一个函数有一个 `double` 的参数，我们却将一个 `int` 的参数传给它。

在编程语言定义的隐式转换之外，用户也可以定义自己的隐式转换：在源类型或者目标类型的类定义上加上适当的成员。
源类型之上的隐式转换是这样定义的：类型转换运算符放在目标类型后面命名（比如 `operator bool()` ）。
目标类型之上的隐式转换是这样定义的：构造函数可以将源类型作为它唯一的参数（或者仅仅是没有缺省值的参数）。

`explicit` 关键字可以用到一个构造函数上或者一个转换操作上（从 C++ 11 开始）。
这个关键字可以确保目标类型仅仅被显式地使用，例如强制转换。
这不只是用在隐式转换上，也适用于 C++ 11 的列表初始化语法：

```C++
class Foo {
explicit Foo(int x, double y);
...
};

void Func(Foo f);
```
```C++
Func({42, 3.14});  // 错了
```

这种代码技术上不是隐式转换，而只是编程语言认为它是显式的。

**优点：**

- 隐式转换可以让类型更可用，当明显需要显式地命名一个类型的时候，这样更有表现力。
- 隐式转换可以简单的取代重载。例如，一个函数包含一个 `string_view` 参数，隐式转换可以取代 `string` 和 `const char*` 的重载。
- 列表初始化语法对于初始化对象而言是简明的和有表现力的。

**缺点：**

- 隐式转换将类型不匹配的BUG藏了起来。目标类型并没有匹配用户的期望，用户并没有意识到转换将要发生。
- 隐式转换让代码更难读了。在重载的位置，实际被调用的代码并不明显。
- 带有单参数的构造函数可能意外地被用于隐式的类型转换，即便本来不打算这么做的。
- 如果不用 `explicit` 关键字修饰带有单参数的构造函数，则是否是隐式转换将不可靠，作者也容易忘记标记它。
- 如果目标类型是隐式的，列表初始化可能面临同样的问题。特别在列表仅仅是单个元素的情况下。

**结论：**

对于类型转换操作符、单参数可调用的构造函数，必须用 `explicit` 关键字标明。
例外的情况是，拷贝和移动构造函数不能是显式的，因为它们不会执行类型转换。
隐式转换有时候是必须的，适当的类型被设计成透明地包裹了其它类型。
在这种情况下，向你的项目领导请求放弃这一规则。

省略了 `explicit` 的单参数的构造函数将不会被调用。
包含 `std::initializer_list` 参数的构造函数也要略去 `explicit` ，这样才能支持拷贝构造（例如：`MyType m = {1, 2};` ）。

### 可拷贝和可移动的类型

当一个类是可拷贝、可移动的或者既可拷贝也可移动的，这个类的公共API应该是显式的。
如果对于你的类型的操作是清晰的和有意义的，那么就支持拷贝和移动。

**定义：**

一个可移动的类型可以被初始化和临时赋值。

在约定初始值不可变的情况下，一个可拷贝的类型是可以被其它对象的同一类型初始化和赋值的（也可以是被定义成可移动的）。
`std::unique_ptr<int>` 是可以移动的，但是不可拷贝（因为 `std::unique_ptr<int>` 的初始值在对目标进行赋值的过程中必须被修改）。
`int` 和 `string` 是可移动的也是可拷贝的。（对于 `int` 而言，移动和拷贝操作是等效的；对于 `string` 而言，移动操作比拷贝操作更不费力。）

对于用户自定义的类型，拷贝构造函数和拷贝分配操作定义了拷贝行为。移动构造函数和移动分配操作定义了移动行为。
要不然，如果拷贝构造函数和拷贝分配操作存在，移动行为由它们定义。

拷贝 / 移动构造函数可以由编译器在某些条件下调用。例如，通过值来传递对象。

**优点：**

可拷贝和可移动的类型的对象可以被传递和通过值来返回，这样可以使API更简单、更安全和更通用。
不同于通过指针和引用来传递对象，不会有所有权、生命周期、易变性和出现类似这些问题的混乱的风险。因此不用在约定中定义它们。
同时也可以防止客户和实现之间非本地的相互作用。这样代码更易懂，更好维护，更好被编译器优化。
更进一步，这样的对象可以请求泛型API传值，例如大多数容器，它们在类型比较时允许额外的灵活性。

拷贝 / 移动构造函数和分配操作通常更容易被定义，比如：`Clone()`  ， `CopyFrom()` 或者 `Swap()`。
因为它们通常是编译器生成的，要么是暗含的或者用 `= default`。它们是简明的，确保所有数据成员被拷贝。
拷贝和移动构造函数通常也更高效，因为它们通常不会请求堆分配内存，或者被单独初始化和分配步骤。
对于 [拷贝省略](https://en.cppreference.com/w/cpp/language/copy_elision) ，它们通常有资格被优化。

移动操作允许隐式的和有效的将资源移出右值对象（rvalue）。在某些情况下，允许更简单的编码风格。

**缺点：**

某些类型不需要被拷贝。对这些类型而言，提供拷贝操作可能带来混淆、无意义或者完全不正确。
表示单例对象的类型（ `Registerer`）、绑定到特定范围的对象（ `Cleanup` ），或者紧密耦合对象实体（ `Mutex` ）都不能被有意图的拷贝。
多态地使用基类类型的拷贝操作是有危险的，这样回导致 [对象分片](https://en.wikipedia.org/wiki/Object_slicing)。
违约的或者不经意实现的拷贝操作是不正确的，导致的BUG会容易混淆和难以诊断。

拷贝构造函数隐式地调用，容易导致调用的缺失。当引用传递被习惯的或者强制的写到代码里面时，容易导致程序员的混淆。
也有可能鼓励过度拷贝，这样容易导致性能问题。

**结论：**

应该显式地声明每个类支持的拷贝和移动操作的公共接口。
通常在类的 `public` 声明区域，应该显式地声明这种形式，和 / 或者删除相应的操作。

特别地，一个可拷贝的类应该显式地声明拷贝操作，一个只可移动的类应该显式地声明移动操作，
一个不可拷贝 / 不可移动的类应该显示地删除相应的拷贝操作。显示地声明或者删除所有这四种操作是被允许但不是必要的。
如果你提供一个拷贝操作或者移动操作，你应该也提供相应的构造函数。

```C++
class Copyable {
 public:
  Copyable(const Copyable& rhs) = default;
  Copyable& operator=(const Copyable& rhs) = default;

  // The implicit move operations are suppressed by the declarations above.
};

class MoveOnly {
 public:
  MoveOnly(MoveOnly&& rhs);
  MoveOnly& operator=(MoveOnly&& rhs);

  // The copy operations are implicitly deleted, but you can
  // spell that out explicitly if you want:
  MoveOnly(const MoveOnly&) = delete;
  MoveOnly& operator=(const MoveOnly&) = delete;
};

class NotCopyableOrMovable {
 public:
  // Not copyable or movable
  NotCopyableOrMovable(const NotCopyableOrMovable&) = delete;
  NotCopyableOrMovable& operator=(const NotCopyableOrMovable&)
     = delete;

  // The move operations are implicitly disabled, but you can
  // spell that out explicitly if you want:
  NotCopyableOrMovable(NotCopyableOrMovable&&) = delete;
  NotCopyableOrMovable& operator=(NotCopyableOrMovable&&)
     = delete;
};
```

这些声明 / 删除操作是可以省略的：例如，如果基类不可拷贝 / 移动，派生类自然也不能。类似的，结构体的拷贝性 / 移动性由它的数据成员的拷贝性 / 移动性来决定（在谷歌的代码里，由于类的数据成员不公开，因此这些类不适用）。注意：如果你显示地声明或者删除任何拷贝 / 移动操作，其它的操作并不明显，这个段落的描述并不适用（通常，这个章节介绍的规则既适用于“类”也适用于结构体的声明或者删除任何拷贝 / 移动操作）。

如果拷贝 / 移动的意义对于临时用户的用意不清楚，那么类型就不应该被拷贝 / 移动，否则这会招致不可预期的开销。对可拷贝类型进行移动操作严格来说是一个性能优化问题，是导致BUG和复杂性的根源。除非这么做比相应的拷贝操作显著地高效，尽量避免这样定义移动操作。如果你要对你的类型提供拷贝操作，建议你很好地设计你的类，正确地编写这些操作缺省的实现代码。如果其它地方要用这些代码，记住重新审查代码的正确性。

由于拷贝分片的风险，最好不要在一个可能被派生的类的定义里提供公共的赋值运算，或者是拷贝 / 移动构造函数（尽量避免用这样的成员去派生这个类）。如果你的基类需要被拷贝，请提供一个虚克隆函数（ `virtual Clone()` ），这样派生出来的类可以实现一个受保护的拷贝构造函数。

### 结构体和类的比较

结构体（ `struct` ）仅仅是用于加载数据，是被动的对象；其它的对象应该用类（ `class` ）来定义。

C++ 语言里面，**结构体**和**类**这两个关键词几乎是对等的。我们在每个关键词上加上了语义的表达， 所以，你应该对于你定义的数据类型采用正确的关键词。

结构体用来被动地加载数据，可能会有相关的常量，但是结构体缺少获取 / 设置数据成员的方法。使用结构体获取 / 设置某些字段的值是直接访问的而不是通过调用方法。只有设置数据成员的时候才用这些方法，例如：构造函数，析构函数，`Intialize()` ， `Reset()` ， `Validate()` 。

如果需要更多的功能，用**类**更合适。如果你不知道怎样才好，那就定义一个类。

为了保持和标准模板库STL的一致性，我们用结构体来定义函子（ `functor` ）和特质（ `traits` ）。

注意：结构体和类里面的成员变量有着不同的命名规则。

### 继承

复合通常比继承更好用。如果你要使用继承，将它定义成公共的（ `public` ）。

一个子类继承了基类定义的所有的数据定义和操作。从纯抽象类（没有状态和方法定义的类）的继承叫做“接口继承”；其它的继承叫做“实现继承”。

由于基类限定了存在的类型，通过复用基类的代码，实现继承减少了程序的代码量。继承是一种编译时的声明，因此程序员和编译器可以很容易理解继承带来的操作并检查出错误。接口继承程序化地保证了类只将特定的API暴露出来。当一个类没有定义某个API的必要方法时，编译器可以识别这种错误。

对于实现继承，编译过程中，基类和子类的实现代码会被展开，因此更难读懂实现的代码。基类不能重载非虚函数，所以基类就不能改变实现代码。

通常，多重继承是特别困难的，因为它强加了更多的性能开销（事实上，相比普通分派到虚分派多重继承比单一继承带来更多的性能衰减）。由于会导致“钻石”型继承模式（由上到下不断扩大）的风险，这样实现代码容易令人费解、混淆，直接带来问题。

所有继承都应该是公共的（ `public` ）。如果你想实现私有的继承，那么就应该在基类里面有个成员实例。

不要滥用实现继承。用复合通常更好。如果 `Bar` 是 `Foo` 的子类，那么我们说 `Bar` 是**一种** `Foo`，而不是说 `Bar` 就**是** `Foo`。尽量限制继承被这样来使用。

保护关键字 protected 也要被限制使用，因为成员函数需要被子类访问。记住数据成员必须是私有的。

虚函数或者虚构筑器要明显的注释出来，用 `override` 或者（不经常地）用 `final` 定义符。声明了重载（ `override` ）就不要用 `virtual` 。依据是：在基类用 override 或者 final 标注的函数或者析构函数不编译，这对捕获常见的错误有帮助。这些定义符还可以作为文档；没有定义符，如果读者想要断定函数或者析构函数是不是虚（ `virtual` ）的，文档里面又没有，他将不得不把这个类的所有继承者挨个都检查一遍。

**多重继承** 是允许的，不过 **多重实现继承** 却相当地不受待见。

### 运算符重载

应该审慎地重载运算符。不要创造用户定义字面量。

**定义：**

只要一个参数是用户自定义的类型，C++ 里面的 `operator` 关键字允许用户用代码去声明 [内置运算符的重载版本](http://en.cppreference.com/w/cpp/language/operators)。 `operator` 关键字也允许定义新种类的字面量，比如用： `operator""`。用 `operator bool()` 这样的代码可以定义类型转换函数。

**优点：**

运算符重载可以让代码变得更简洁。和内置的类型一样，允许用户自定义的类型，代码表现得很直观。
重载的运算符通常是某些操作的惯用法名字，例如，`==` 、 `<` 、 `=` 和 `<<` 。附上这些转换，代码更好阅读，这使得和需要这些名字的代码库的交互操作成为可能。

对于创造用户定义的类型而言，用户定义字面量是非常简明的记号。

**缺点：**

- 要非常小心地提供正确的、一致的、意料之中的运算符重载，否则这样做会带来混淆和BUG。
- 滥用运算符会导致代码含糊不清，特别是运算符的语义没有遵循转换操作的规范。
- 函数重载的危害和运算符重载的危害一样大，甚至更甚。
- 不要以为耗时运算是廉价的，本来就是内置的运算，就愚弄我们的直觉。
- 找到运算符重载调用的位置，可能需要动用搜索工具，还要考虑 C++ 的语法，而不是简单地用 `grep`。
- 如果你用错了运算符重载的参数类型，可能你都看不到编译错误信息，你调用的是一个不同的重载。
例如， `foo < bar` 和 `&foo < &bar` 是完全不同的两回事。
- 某些运算符重载本来就是有害的。重载一元运算符 `&` 在同样的代码会有不同的含义，这取决于这个重载声明是否可见。 `&&` 、 `||` 和 `,` 这些运算符的重载和内置操作语义上的执行顺序并不一致。
- 运算符经常被定义在类的外面。因此对于同样的运算符，不同文件就会引入不同的定义，这就危险了。如果定义都被链接到同一个库里面，这会导致未定义的行为，微妙的运行时错误就出来了。
- 即使对于有经验的 C++ 程序员来说，允许创造新语法形式的用户定义字面量也是不常见的。

**结论：**

只有重载的运算符是明显的、意料之中，与相应的内置运算符是一致的，我们才定义它。比如，我们用 `|` 作为位运算或者逻辑或运算，而不是作为一个 [`shell`](http://www.runoob.com/linux/linux-shell.html) 形式的管道符。

只在你自己的类型里定义运算符。更准确地来说，作为运算的类型，在同样的头文件，`.cc` 文件和名字空间里面定义它们。这样一来，不管类型在哪里，运算都是可用的，减少了多重定义的风险。如果可能的话，不要把运算符定义成模板，因为它们必须满足所有的模板参数规则。如果你定义一个运算符，那么也要定义相应的好理解的运算操作，确保它们的定义是一致的。举个例子，如果你重载 `<` ，所有这些比较操作都要重载，确信 `<` 和 `>` 对于同样的参数都不会返回 `true` 。

把不可修改的二进制运算符定义成非成员函数要更好。如果一个二进制运算符被定义成类成员了，隐式的转换将被用到右边的参数上，而不是左边的参数。这样你的用户容易搞混了：`a < b` 编译而 `b < a` 不编译。

不要刻意地定义运算符重载。例如，更喜欢用 `==` 、 `=` 和 `<<`，而不是 `Equanls()` 、`CopyFrom()` 和 `PrintTo()` 。反过来说，不要因为别的类库想要用它而去定义运算符重载。例如，你的类型并没有自然的顺序，但是你还是想把它存在一个 `std::set` 里面，这个时候，用一个自定义的比较器就可以了，不要去重载 `<` 运算符了。

不要重载 `&&` 、 `||` 和 `,` ，或者一元运算符 `&` 。不要重载 `operator""` ，不要带入用户定义字面量。

类型转换运算符在上面的章节 [隐式转换](#隐式转换) 有介绍。`=` 运算符在上面的章节 [拷贝构造函数](#拷贝构造函数) 有介绍。`<<` 运算符的重载在下面的章节 [流](#流) 里面有介绍。参见 [函数重载](#函数重载) 里面的规则，对运算符重载也是适用的。


### 访问控制

将类成员数据设置成私有的 `private` ，除非它们是静态常量（ `static const` ，参考下面的 [常量的命名惯例](#常量命名) ）。

由于技术的原因，在使用 [谷歌测试](https://github.com/google/googletest) 的时候，一个 `.cc` 文件中的测试固定环境类的数据成员是被保护的 `protected` 。

### 声明的顺序

将类似的声明都组合在一起，放在公共的部分之前。

一个类的定义应该从 `public:` 代码段开始，后面跟着是 `protected:` 代码段，然后是 `private:` 代码段。略去的部分应该是空的。

在每个代码段，相似种类的声明最好被组合到一起，通常依照这样的顺序：
类型（包括 `typedef` ，`using` ，嵌套的结构体和类），常量，工厂方法，构造函数，赋值运算，析构函数，其它的方法，数据成员。

不要把大量的方法定义写到类的定义里面。通常，只有琐碎的或者性能关键的，还有非常短小的，这样的方法被定义成内联的（  `inline` ）。具体请参考 [内联函数](#内联函数) 。

## 函数

### 输出参数

最好用返回值而不是输出参数。如果参数仅仅用来输出值，那就应该放到输入参数的后面。

C++ 函数的输出结果通常通过返回值来实现，有时候也会用输出参数。

参数或者是到函数的入口，或者是函数的出口，或者同时输入和输出。输入参数通常是值或者常量引用，而输出参数和输入 / 输出参数应该是指向非常量的指针。

注意函数参数的顺序，把只输入的参数放在任何输出参数的前面。特别注意的是，不要因为一个函数是新的，就把新的参数加到函数的结尾；新的只输入的参数还是要放到输出参数的前面。

这里没有一成不变的规则。既输入又输出的参数（通常是类 / 结构体）经常把事情弄糟了，要保持相关函数的一致性你又要放松一些规则。

### 写短的函数

尽量写短的函数和目标明确的函数。

我们认识到长的函数有时候也是合适的，所以没有硬性规定函数的长度。如果一个函数超过了40行，在不破坏程序结构的前提下，应该考虑将它拆散了。

即使你写的长函数工作起来是正确的，几个月之后别人的改动又会增加新的行为。这可能带来难以寻找的BUG。保持你写的函数短小精悍，这样别人好读懂也好修改。

你可能在一些代码里面看到那些又长又复杂的函数。不要被修改这样的代码吓怕了：如果这些函数的用处被证明是难懂的，错误很难被调试出来，那就考虑拆散这些函数，变成更短小更好管理的片段。

### 引用参数

所有被左值（ `lvalue` ）引用传递的参数都应该用 `const` 标注。

**定义：**

在 C 语言里面，如果一个函数要修改一个变量，参数就必须是指针类型的，比如，`int foo(int *pval)` 。而在 C++ 语言里，函数可以替代地声明一个引用参数： `int foo(int &val)` 。

**优点：**

通过引用定义一个参数可以避免代码难看，比如： `(*pval)++` 。这对于某些应用比如拷贝构造函数是必要的。不像用指针那样，这样是清晰的，因为空指针是不可能的值。

**缺点：**

引用容易导致混淆，因为语法上是 **值** 语义上又是 **指针** 。

**结论：**

函数参数内部使用的引用参数应该是常量定义，不变的 `const` ：

```C++
void Foo(const string &in, string *out);
```

实际上，在谷歌代码里，有非常强的惯例约定：输入参数是值或者 `const` 引用，输出参数是指针。
输入参数可能是 `const` 指针，但是我们不允许非  `const` 的引用。除非是惯例需要这样做的，比如： `swap()` 。

但是，这里也有些这样的实例，用 `const T*` 比用 `const T&` 更好。例如：

- 你真的想传递一个空指针。
- 函数保存了一个指针或者引用到输入参数。

记住，大多数时候，输入参数都将被定义成 `const T&` 。
而用 `const T*` 这个是为了告诉读者输入参数被以某种方式不同地处理了。
所以，你用 `const T*` 而不用 `const T&` 是因为一个具体原因，
否则会混淆读者，让他们去找一个不存在的阐述。

### 函数重载

使用重载的函数（包括构造函数）的目的是：
当读者看到一个调用的位置是，他能很好地理解正在发生的事情，
而不是首先要确切地弄清楚哪个重载被调用了。

**定义：**

你可能用一个 `const string&` 写了一个函数，另外又用 `const char*` 重载了它。
但是，在这种情况下请考虑用 `std::string_view` 取而代之：

```C++
class MyClass {
 public:
  void Analyze(const string &text);
  void Analyze(const char *text, size_t textlen);
};
```

**优点：**

采用带有不同参数的同名函数让代码变得更直观了。
这可能对于模板化的代码是必要的，对于访问者而言更方便了。

基于 `const` 或者引用限定条件的重载可能会让实用代码更好用、更高效或者兼而有之。
（参考 [TotW #148](https://abseil.io/tips/148) ）

**缺点：**

一个函数仅仅是参数类型不同被重载，读者必须对 C++ 语言的复杂性有所认识，
从而知道将要发生的事情匹配的规则。继承的语义常常让许多人都搞混了：
一个派生类仅仅只是重载了一个函数的一些变体。

**结论：**

当函数的变体之间没有什么语义的不同时，你可以重载这个函数。类型不同、修饰符不同、参数数量不同，这些都会导致重载的不同。但是，作为读者，不需要知道被选定的是哪个重载集的成员，只需要知道被调用的重载集是谁就行。如果你在一个文档的首部用注释说明了重载集的所有条目，那将是一个设计周到的好迹象。

### 缺省参数

如果缺省值总是同样的值，非虚函数可以使用缺省参数。
上面的 [函数重载](#函数重载) 也作了同样的约束。
如果可读性可以得到保障，那么最好使用采用了缺省参数的重载函数，只要不超出下面描述的缺点的范围。

**优点：**

很多时候你有了一个用了缺省值的函数，偶尔你又想覆盖这些缺省值。除了极少数的例外，函数采用缺省参数是一个比较好的方法，不必再定义许多函数了。与函数重载相比，使用缺省参数的函数语法更干净。它用更少的样板就更清晰地区分了“需要的”和“可选的”参数。

**缺点：**

缺省参数是实现重载函数语义的另一种方法。这也是 [不用重载函数的原因](#函数重载) 。

一个虚函数的缺省参数由目标对象的静态类型来决定。不能保证一个指定函数的所有重写都声明了同样的缺省值。

每个调用的位置，缺省参数会被重新计算，这样会膨胀所生成的代码。读者也许会希望缺省值像声明的那样是固定的，而不是每次调用都会不同。

有缺省参数的情况下，函数指针会难以理解。因为函数签名和调用签名会不一样。添加函数重载避免这些问题。

**结论：**

取决于什么时候被计算出来，特定的缺省值可能被算出来不一样的值。虚函数的缺省参数是被禁用的，因为它们不能正常工作。（例如，不要这样写代码： `void f(int n = counter++);` 。）

在其它的情况下，缺省参数可以提高可读性，因为足够的函数声明可以上面所述的缺点。没有把握的时候，那就用重载。

### 尾随的返回类型语法

尾随的返回类型仅仅用在当普通的语法（主要的返回类型）不好用或者缺乏可读性时。

**定义：**

C++ 允许两种不同形式的函数声明。旧的形式是，返回类型放在函数名的前面。例如：

```C++
int foo(int x);
```

C++ 11 引入的新形式是，函数名前面使用 `auto` 关键字，尾随的返回类型跟在参数列表的后面。例如，上面写的代码声明也可写成这样：

```C++
auto foo(int x) -> int;
```

尾随的返回类型在函数的作用域里面。像是返回 `int` 这种情况没有什么不同，但它会带来更复杂的情况：像是参数声明在类的作用域里面，又或者类型被写在函数的参数里面。

**缺点：**

尾随的返回类型是定义 [lambda表达式](#lambda表达式) 的唯一方法。有时候，编译器能够推导出一个lambda的返回类型，但不是所有情况都这样。只有当编译器可以自动的推导出来的时候，显式地定义它才是对读者清晰易懂的。

有时候在一个已经出现函数参数列表的后面定义一个返回类型更容易也更可读。
当返回类型依赖于模板参数类型的时候，尤其如此。例如：

```C++
template <typename T, typename U>
auto add(T t, U u) -> decltype(t + u);
```

与之相对的：

```C++
template <typename T, typename U>
decltype(declval<T&>() + declval<U&>()) add(T t, U u);
```

**缺点：**

C++ 一类的语言如 C 、Java 这些语言里，尾随的返回类型还是一个相对比较新的语法。某些读者可能会不适应。

现有的代码中，相当多的函数声明都没有打算改成这个新语法。所以，更为实际的选择是，要么仅仅使用旧的语法，要么两者混合使用。采用一种版本的语法更有利于代码风格的统一。

**结论：**

在大多数情况下，继续使用函数声明的旧的语法，将返回值放在函数名的前面。仅仅在需要的时候，才采用尾随的返回类型的形式（比如 `lambda` 表达式），将返回类型放在函数参数列表的后面。这使你写的代码里的类型更可读。后者应该更少见。[在很多情况下](#模板元编程) 不鼓励这样做，在相当复杂的模板代码里，这通常是一个问题。

## 谷歌特定的技巧

这里有一些不同的技巧和实用工具，我们可以用来增加 C++ 代码的健壮性。这些方法可能和你在别的地方看到的有些不同。

### 所有权和智能指针

对于动态分配的对象，单一的、固定的所有者更好。用智能指针更好实现所有权转移。

**定义：**

所有权是一种记账技术，用于动态内存分配（和其它资源）。动态分配对象的所有者是指对象或者函数当不再需要的时候要负责确保它被删除了。所有权有时候可以被共享，如果上一个所有者通常可负责地删除它的情况下。即便是所有权不能共享，它也可以从一片代码转移到另一片代码。

“**智能**” 指针是一些表现得像指针一样的类，例如，通过重载 `*` 和 `->` 运算符。某些智能指针可以被用来实现自动所有权记账，以确保满足这些职责。`std::unique_ptr` 是一个 C++ 11 引入的智能指针类型。它对于一个动态分配的对象表现出独有的所有权。当 `std::unique_ptr` 离开作用域的时候，对象就被删除。它不能被拷贝，但是可以被移动到代表所有权转移的位置上。
而 `std::shared_ptr` 这个智能指针则代表共享的一个动态分配对象的所有权。`std::shared_ptr` 可以被拷贝；对象的所有权被所有的拷贝共享着。当最后一个 `std::shared_ptr` 被销毁的时候对象就被删除。

**优点：**

- 如果没有某种逻辑的所有权，实际上是不可能管理动态分配的内存的。
- 对象所有权的转移比拷贝对象更廉价（如果都不能拷贝对象的时候）。
- 智能指针增加了程序可读性，它让所有权的逻辑更明确，自我归档，也没有歧义。
- 智能指针可以淘汰手工所有权记账，简化代码，排除大量的错误的类。
- 对于常对象（ `const objects` ）而言，共享所有权是深拷贝的替代品。

**缺点：**

- 所有权必须通过指针来表达和传输（不论是智能指针还是普通指针）。指针语义比值语义更复杂了。特别是在这样的API里面：你不仅仅关心的是所有权，你在其它议题之中还考虑了别名使用、生命周期和易变性。
- 值语义的性能开销往往被高估了。因此所有权转移带来的性能优势并不能证明可读性和复杂性的开销是恰当的。
- 所有权转移的API迫使使用者变成了一个单一的内存管理模型。
- 关于资源释放发生的地方，使用智能指针的代码并没有那么明确的说明。
- 采用 C++ 11 的移动语义，比如 `std::unique_ptr` 所代表的所有权转移，这个概念相对较新，让某些程序员混淆。
- 对于细致的所有权设计而言，共享所有权是一个诱人的替代品，但是却搞模糊了系统的设计意图。
- 共享所有权需要运行时的明确记账，这可能开销比较大。
- 某些情况下（例如，循环的引用），共享所有权的对象可能不能被删除。
- 智能指针并不是普通指针更好的替代品。

**结论：**

如果动态分配是必须的，那么最好保持分配它的代码的所有权。如果其它代码也要访问这个对象，考虑传递一份拷贝，要么传递一个指针或者引用，不是传输所有权。为了让所有权转移更明显，最好用 `std::unique_ptr` 这个智能指针。例如：

```C++
std::unique_ptr<Foo> FooFactory();
void FooConsumer(std::unique_ptr<Foo> ptr);
```

没有很好的理由，就不要把你的代码设计成使用共享所有权。一个原因是要避免奢侈的拷贝操作。只有在性能优势明显和隐含的对象是不可变的情况下，你才这么做。（例如，`std::shared_ptr<const Foo>` ）如果使用共享所有权，最好是用 `std::shared_ptr` 这个智能指针。

不要用 `std::auto_ptr` 。改为，用 `std::unique_ptr` 。

### cpplint

**cpplint.py** 这个脚本可以检测代码风格错误。

**cpplint.py** 读入一个源代码文件，将许多代码风格错误识别出来。它还不完美，可能有误报和漏报。
但一直是很有用的工具。在文件的末尾行放上 `// NOLINT` 可以忽略误报，也可以在误报的前面哪一行放上 `// NOLINTNEXTLINE` 。

有些项目中，关于如何在项目工具中运行 **cpplint.py** 有操作指南。如果你贡献的项目没有这样做，那你就单独地下载这个脚本 [cpplint.py](https://raw.githubusercontent.com/google/styleguide/gh-pages/cpplint/cpplint.py)。

## 其它 C++ 特征

### 右值（Rvalue）引用

右值引用通常用于：

- 定义移动构造函数和移动赋值运算。
- 用 `const&` 和 `&&` 变量定义 [重载集](#函数重载) ，如果你认为这样做会比值传递带来明显的性能提升的话。或者为了支持任意的类型，你正在写低开销的泛型代码。要担心组合的重载集，很少用超过一个参数的重载。
- 在泛型代码里面支持“完美转发（ `perfect forwarding` ）”。

**定义：**

右值引用是一种唯一绑定到临时对象的引用类型。它和传统的引用语法相似。
例如，`void f(string&& s);` 声明了一个函数，它的参数是一个字符串的右值引用。

当一个函数有一个不合格的模板参数被加上了 `&&` 标记，特殊的模板参数推导规则就被用上了。这样的引用被称之为转发引用（ `forwarding reference` ）。

**优点：**

- 可以定义一个移动构造函数（一个采用类型的左值引用的类的构造函数）来移动一个值而不是拷贝它。
例如：`v1` 是一个 `std::vector<string>` ，代码 `auto v2(std::move(v1))` 可能作用的结果是一些简单的指针处理操作而不会拷贝大量的数据。在很多情况下，这样做都会带来主要的性能提升。
- 右值引用使得不可拷贝而可移动的类型实现成为可能。这对那些没有合理定义的类型是有用的。在你一直想要作为函数参数去传递它们的时候，把它们放到容器里。
- 为了有效地利用某些标准库类型，比如 `std::unique_ptr` ，`std::move` 是必须的。
- 转发引用采用右值引用标记，这使得编写泛型函数的包裹器，将它的参数传递给其它函数成为了可能。不管这个函数的参数是否是临时对象的还是 `const` 的。这就叫做“完美转发”。

**缺点：**

- 右值引用通常不被广泛的理解。移动构造函数的自动合成和引用崩塌规则有几分晦涩难懂（后面会提到，特殊的规则用在一个 `T&&` 参数上面）。
- 右值引用经常被误用。当函数被调用之后，参数通常希望有一个特定的状态，在签名上用上右值引用是反直觉的。否则没有移动操作被执行。

**结论：**

你可能会用右值引用来定义移动构造函数和移动赋值运算（就像 [可拷贝和可移动的类型](#可拷贝和可移动的类型) 里面描述的那样）。参考 [C++ 入门](https://google.github.io/styleguide/primer#copying_moving) 里面的关于移动的语义和 `std::move` 的章节的更多信息。

你也可能会用右值引用来定义成对的重载，一个用 `Foo&&` 另一个用 `const Foo&` 。通常更应该公正地对待值传递。但是一个函数对的重载有时产出更好的性能，有时在泛型代码里面是必须的，必须支持各种各样的类型。总要注意：如果你正在为性能的理由而编写出更复杂的代码，你必须确认这样真的表明有所帮助。

要实现“完美转发”，那就将转发引用和 `std::forward` 一起用上。

### 友元

我们允许合理地使用友元（ `friend` ）类和函数。

友元通常被定义在同一个文件内部，读者不用查找其它文件就可以找到类的私有成员的用法。通常的用法是，一个 `Foo` 类的友元通常有一个 `FooBuilder` 类，因此它可以正确地构造 `Foo` 这个类的内部状态。不需要将这一状态向全世界公开。在一些情况下，要制造一个单元测试类来测试的类的友元。

友元扩展了类的封装边界，并没有破坏它。有些情况下，这比把一个成员设成公共的更好。因为你只想让一个其它的类可以访问它。但是，更多的类应该通过公共的成员来与其它类单独地交流。

### 异常

我们不使用 C++ 异常。

**优点：**

- 异常使得应用程序的上层可以处理深度嵌套函数产生的“不可能发生的”错误。没有错误代码的费解和易于出错的记账。
- 异常被其他的现代语言采用。在 C++ 语言里使用异常，将使得它和其它熟悉的语言保持一致，比如 Python、Java 语言。
- 一些第三方的 C++ 库代码使用了异常，内在地关闭这些异常就很难和这些库进行集成。
- 对于构造函数失败而言，异常处理是唯一的方法。我们可以用工厂方法或者 `Init()` 方法来模拟它，但是这分别需要堆分配内存或者一个新的“非法的”状态。
- 异常实际上对于测试框架很好用。

**缺点：**

- 当你对一个存在的函数添加一个 `throw` 语句的时候，你必须执行它所有的可传递的调用者。要么它们至少对基本的异常有安全的保证，要么结果是它们必须捕获异常并且有助于程序终止。举个例子，如果 `f()` 调用了 `g()` 调用了 `h()` ，`h` 抛出一个异常被 `f` 捕获，那么 `g` 必须小心了，有可能它没有收拾干净。
- 更通常的情况下是，异常让程序的控制流程更难执行了，你可以看看代码：函数可能在你不想要的地方返回了。这让维护和调试都变困难了。你可以定义一些规则，表明哪里可以使用异常和怎样使用异常。但是这样做比让程序员知道和理解的开销更大。
- 安全的处理异常既需要资源申请即初始化（RAII），也需要不同的代码实践。大量的支持机构让编写正确的异常安全代码更容易。更进一步，为了避免要求读者读懂整个的调用图，异常安全代码必须隔离写进提交阶段的持久状态的逻辑。这既有好处也有坏处（你被迫混淆代码以隔离提交）。即使不值得这样做，允许使用异常总会让我们付出这些代价。
- 添加数据到每个生成的二进制程序里，打开异常，这会增加编译时间（可能略微地），可能会增加地址空间的压力。
- 持异常有效性的人认为：当不合时宜的时候或者不能安全的从异常恢复的时候，就将异常抛出来。例如，非法的用户输入应该不会导致抛出异常。我们必须制作编码规范甚至花更长的时间把约束写到文档里。

**结论：**

表面上看来，使用异常的好处超过了使用异常的代价。尤其在新项目是如此。但是，对于已有的代码，引入异常会牵连所有依赖的代码。如果异常的普及超出了新项目的范围，它也会变成集成的项目的问题，原有的没有使用异常的代码也必须用上。在谷歌，大多数已有的 C++ 代码不准备处理异常。让新的代码生成异常相对而言比较困难。

考虑到谷歌现有的代码并不是容忍异常的，相比新的项目，采用异常的代价太大了。做代码转换又慢又容易出错。我们不相信有好的替代品可以使用异常，比如错误处理代码和断言，这只会使任务加重。

我们反对使用异常的建议并不是作为哲理的声明和道德基础，而是实践使然。因为我们更喜欢在谷歌内部使用开源项目，这些项目使用异常是困难的，所以我们建议也不要在谷歌的开源项目上使用异常。如果我们能重新来过从头开始事情会变得不一样。

这个禁令也适用于 C++ 11 里面相应的异常处理特征，例如 `std::exception_ptr` 和 `std::nested_exception` 。

对于 Windows 的代码，这个规则（没别的意思）有个 [例外](https://google.github.io/styleguide/cppguide.html#Windows_Code) 。

### noexcept

定义 `noexcept` 当它有用和正确的时候。

**定义：**

`noexcept` 说明符用于具体指定函数要不要抛出异常。如果一个异常从标记了 `noexcept` 的函数溢出，那么这个程序会以 `std::terminate` 崩溃。

`noexcept` 操作符会执行编译时的检查，如果一个表达式声明了不抛出任何异常的话，那就返回 `true` 。

**优点：**

- 在某些情况下，将移动构造函数指定为 `noexcept` 的话可以提高性能。比如，假如 `T` 的移动构造函数是 `noexcept` 的，那么`std::vector<T>::resize()` 移动对象而不拷贝对象。
- 在有异常的情况下，指定一个函数是 `noexcept` 的话会触发编译器优化。例如，编译器不必为栈展开而生成额外的代码，由于 `noexcept` 说明符，编译器知道没有异常可以被抛出。

**缺点：**

- 遵循这个规范使得项目里面的异常被禁用了。很难确保 `noexcept`  说明符是正确的，也难以定义正确性意味着什么。
- 很难也不可能撤销 `noexcept` ，因为调用者信赖的担保被去掉了。这种情况难以检测。

**结论：**

 `noexcept` 对于性能确实有用。它确实显示了你的函数语义的预期效果。也就是说，如果一个函数体的内部不知何故抛出了异常，它意味着一个致命的错误。你可以假定移动构造函数上面的 `noexcept` 会带来重大的性能提升。你可以和你的领导商量在别的函数上指定 `noexcept` ，因为有重大的性能提升。
 
 因为异常被完全的禁用了，无条件的使用 `noexcept` 会更好（大多数谷歌的 C++ 环境都是这样的）。相反地，在某些条件下有条件的使用 `noexcept` ，少数情况下那些潜在的抛出异常的函数会执行错误。测试是否包含类型特质查，是否相关的操作会被抛出（例如： `std::is_nothrow_move_constructible` 被用在移动构造对象），或者是否内存分配会被抛出（例如：`absl::default_allocator_is_nothrow` 被用在标准缺省的内存分配）。请注意：在许多情况下，内存分配失败都是异常出现唯一可能的原因（我们相信移动构造函数并不会因为分配失败而抛出）。许多应用程序都把内存消耗看成是致命错误，而不是你的程序应该试图去恢复的例外情况。对于其它潜在的故障而言，应该优先考虑接口简单化，以满足所有可能抛出异常的场景：一个哈希函数是否抛出异常，不用去写复杂的 `noexcept` 子句。简单地记录你的哈希函数不支持抛异常，无条件的标明它 `noexcept` 。
 
 ### 运行时类型信息（RTTI）
 
 要避免使用运行时类型信息（RTTI）。
 
 **定义：**
 
 RTTI 使得程序员在运行时去查询一个对象的 C++ 类。通常用 `typeid` 和 `dynamic_cast`。
 
 **缺点：**
 
 频繁地查询一个对象的类型意味着设计有问题。运行时需要知道一个对象的类型通常表明你的类的层次结构设计上有瑕疵。
 
 泛滥地使用RTTI让程序难以维护。这会导致基于类型的决策树和 `switch` 语句散落在整个代码的各个地方，更多的变化通通都被必须被执行。
 
 **优点：**
 
 RTTI（下面描述的）的标准替代品需要修改和重新设计类的层次结构。有时候这样的修改不得人心又办不到，特别是那些广泛使用的代码和成熟的代码。
 
 RTTI 可以被用在某些单元测试。例如，验证一个新创建的对象拥有期望的动态类型，RTTI 对于工厂类的测试是有用的。也可以用在管理对象和它们的模拟的关系上。
 
 考虑多个抽象对象，RTTI 确实有用，比如：
 
```C++
bool Base::Equal(Base* other) = 0;
bool Derived::Equal(Base* other) {
  Derived* that = dynamic_cast<Derived*>(other);
  if (that == nullptr)
    return false;
  ...
}
``` 

**结论：**

RTTI 有正当合理的用法，但是容易被滥用。所以必须小心仔细地用它。在单元测试里，你可以随意使用它。其它代码里，不要使用它。特别地，在新代码使用 RTTI 之前思考两遍。如果你发现你的代码基于的对象的类需要不同的表现，考虑用下面的替代品去查询类型：

- 依赖于特定子类的类型，虚方法是执行不同代码路径更好的方法。把这个任务放到对象的内部也是可行的。
- 如果这个任务属于对象的外部，而不在某些处理代码的内部，考虑使用双重分派吧，例如访问者设计模式。这个模式允许对象以外的装置用内置的类型系统自行决定类的类型。

当一个基类的给定实例就是特定的派生类的实例，程序的逻辑保证这样执行的话，那么 `dynamic_cast` 就可随意地用在对象上面。通常，这种条件下，也可以用 `static_cast` 作为替代。

基于类型的决策树强烈地表明了你的代码被用在了错误的轨迹上：

```C++
if (typeid(*data) == typeid(D1)) {
   ...
} else if (typeid(*data) == typeid(D2)) {
  ...
} else if (typeid(*data) == typeid(D3)) {
  ...
```

添加到类的层次关系上的附加子类通常会被这样的代码破坏。更有甚者，当一个子类的属性发生了变化，很难发现和修改受影响的所有代码段。

不要手工实现诸如 RTTI 这样的解决方案。反对使用 RTTI 的论据同样适用于像附有类型标签的类的层次结构这样的解决方案。并且，解决方案隐瞒了你的真实意图。

### 强制类型转换

C++规范使用这样形式的类型转换 `static_cast<float>(double_value)` ，或者用大括号初始化算术类型，比如 `int64 y = int64{1} << 42` 。不要这样使用类型转换格式，比如 `int y = (int)x` 或者 `int y = int(x)` （当调用类类型构造函数时，后面这种形式是允许的）。

**定义：**

C++ 的类型转换系统和 C 语言不一样，可以明显地标识类型转换运算。

**优点：**

C 语言的类型转换运算含糊不清。比如， `(int)3.5` 是类型转换；`(int)"hello"` 是强制转换。C++ 语言使用大括号初始化和强制类型转换可以避免歧义。另外，C++ 的强制类型转换更方便查找。

**缺点：**

C++ 规范的强制类型转换语法冗长又笨拙。

**结论：**

禁用 C 语言的强制类型转换。必须用显示类型转换的地方，只采用下面的 C++ 语言规范：

- 用大括号初始化转换算术类型，例如，`int64{x}` 。这是最安全的方法，因为转换的结果缺少信息，代码将不会被编译。语法也是简明的。
- `static_cast` 相当于 C 语言规范里面的值转换。适用于两种情况：显式地将一个类的指针强制向上类型转换成父类的指针时；或者显式地把一个父类的指针强制转换成子类的指针时。后面这种情况，要保证对象确实是子类的实例。
- `const_cast` 用于移除 `const` 修饰符。（见 [const](#const修饰符)）
- `reinterpret_cast` 用于不安全的指针类型转换，从整型或者其他指针类型，反之亦然。这会带来别名问题和其他问题。

`dynamic_cast` 的用法请参考 [RTTI](#运行时类型信息rtti) 章节的说明。
